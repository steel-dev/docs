---
title: Captcha Solving
sidebarTitle: Captcha Solving
description: A step-by-step guide to connecting Steel with Browser-use and solving captchas.
llm: true
---

This guide walks you through connecting a Steel cloud browser session with the browser-use framework, enabling an AI agent to interact with websites.

#### Prerequisites

Ensure you have the following:

*   Python 3.11 or higher

*   Steel API key (sign up at [app.steel.dev](https://app.steel.dev/))

*   OpenAI API key (sign up at [platform.openai.com](https://platform.openai.com/))


#### Step 1: Set up your environment

First, create a project directory, set up a virtual environment, and install the required packages:

```bash Terminal -wc
# Create a project directory
mkdir steel-browser-use-agent
cd steel-browser-use-agent

# Recommended: Create and activate a virtual environment
uv venv
source .venv/bin/activate  # On Windows, use: .venv\Scripts\activate

# Install required packages
pip install steel-sdk browser-use python-dotenv
```

Create a `.env` file with your API keys:

```env ENV -wcn -f .env
STEEL_API_KEY=your_steel_api_key_here
OPENAI_API_KEY=your_openai_api_key_here
TASK=Go to Wikipedia and search for machine learning
```

#### Step 2: Create a Steel browser session and initialize Tools and Session Cache

Use the Steel SDK to start a new browser session for your agent:

```python Python -wcn -f main.py
import os
from steel import Steel
from dotenv import load_dotenv

# Load environment variables
load_dotenv()
STEEL_API_KEY = os.getenv("STEEL_API_KEY") or "your-steel-api-key-here"

# Validate API key
if STEEL_API_KEY == "your-steel-api-key-here":
    print("‚ö†Ô∏è  WARNING: Please replace with your actual Steel API key")
    print("   Get your API key at: https://app.steel.dev/settings/api-keys")
    return

# Create a Steel browser session and initialize Tools and Session Cache
tools = Tools()

client = Steel(steel_api_key=STEEL_API_KEY)

SESSION_CACHE: Dict[str, Any] = {}

session = client.sessions.create()

print("‚úÖ Steel browser session started!")
print(f"View live session at: {session.session_viewer_url}")
```


This creates a new browser session in Steel's cloud. The session\_viewer\_url allows you to watch your agent's actions in real-time.

#### Step 3: Define the Captcha Solving tools available to the Agent

```python Python -wcn -f main.py
def _has_active_captcha(states: List[Dict[str, Any]]) -> bool:
    for state in states:
        if bool(state.get("isSolvingCaptcha")):
            return True
    return False


def _summarize_states(states: List[Dict[str, Any]]) -> Dict[str, Any]:
    summary: Dict[str, Any] = {
        "pages": [],
        "active_pages": 0,
        "total_tasks": 0,
        "solving_tasks": 0,
        "solved_tasks": 0,
        "failed_tasks": 0,
    }

    for state in states:
        tasks = state.get("tasks", []) or []
        solving = sum(1 for t in tasks if t.get("status") == "solving")
        solved = sum(1 for t in tasks if t.get("status") == "solved")
        failed = sum(
            1
            for t in tasks
            if t.get("status") in ("failed_to_detect", "failed_to_solve")
        )

        summary["pages"].append(
            {
                "pageId": state.get("pageId"),
                "url": state.get("url"),
                "isSolvingCaptcha": bool(state.get("isSolvingCaptcha")),
                "taskCounts": {
                    "total": len(tasks),
                    "solving": solving,
                    "solved": solved,
                    "failed": failed,
                },
            }
        )
        summary["active_pages"] += 1 if bool(state.get("isSolvingCaptcha")) else 0
        summary["total_tasks"] += len(tasks)
        summary["solving_tasks"] += solving
        summary["solved_tasks"] += solved
        summary["failed_tasks"] += failed

    return summary


@tools.action(
    description=(
        "You need to invoke this tool when you encounter a CAPTCHA. It will get a human to solve the CAPTCHA and wait until the CAPTCHA is solved."
    )
)
def wait_for_captcha_solution() -> Dict[str, Any]:
    session_id = SESSION_CACHE.get("session_id")
    timeout_ms = 60000
    poll_interval_ms = 1000

    start = time.monotonic()
    end_deadline = start + (timeout_ms / 1000.0)
    last_states: List[Dict[str, Any]] = []

    while True:
        now = time.monotonic()
        if now > end_deadline:
            duration_ms = int((now - start) * 1000)
            return {
                "success": False,
                "message": "Timeout waiting for CAPTCHAs to be solved",
                "duration_ms": duration_ms,
                "last_status": _summarize_states(last_states) if last_states else {},
            }
        try:
            # Convert CapchaStatusResponseItems to dict
            last_states = [
                state.to_dict() for state in client.sessions.captchas.status(session_id)
            ]

        except Exception:
            duration_ms = int((time.monotonic() - start) * 1000)
            print(
                {
                    "success": False,
                    "message": "Failed to get CAPTCHA status; please try again",
                    "duration_ms": duration_ms,
                    "last_status": {},
                }
            )
            return "Failed to get CAPTCHA status; please try again"

        if not last_states:
            duration_ms = int((time.monotonic() - start) * 1000)
            print(
                {
                    "success": True,
                    "message": "No active CAPTCHAs",
                    "duration_ms": duration_ms,
                    "last_status": {},
                }
            )
            return "No active CAPTCHAs"

        if not _has_active_captcha(last_states):
            duration_ms = int((time.monotonic() - start) * 1000)
            print(
                {
                    "success": True,
                    "message": "All CAPTCHAs solved",
                    "duration_ms": duration_ms,
                    "last_status": _summarize_states(last_states),
                }
            )
            return "All CAPTCHAs solved"

        time.sleep(poll_interval_ms / 1000.0)
```

#### Step 4: Define Your Browser Session

Connect the browser-use BrowserSession class to your Steel session using the CDP URL:

```python Python -wcn -f main.py
from browser_use import Agent, BrowserSession

# Connect browser-use to the Steel session
cdp_url = f"wss://connect.steel.dev?apiKey={STEEL_API_KEY}&sessionId={session.id}"
browser_session = BrowserSession(cdp_url=cdp_url)
```


#### Step 5: Define your AI Agent

Here we bring it all together by defining our agent with what browser, browser context, task, and LLM to use.

```python Python -wcn -f main.py
# After setting up the browser session
from browser_use import Agent
from browser_use.llm import ChatOpenAI

# Create a ChatOpenAI model for agent reasoning
model = ChatOpenAI(
    model="gpt-4o",
    temperature=0.3,
    api_key=os.getenv('OPENAI_API_KEY')
)

# Define the task for the agent
task = os.getenv("TASK") or "Go to Wikipedia and search for machine learning"

# Create the agent with the task, model, browser session, and tools
agent = Agent(
    task=task,
    llm=model,
    browser_session=browser_session,
    tools=tools,
)
```


This configures the AI agent with:

*   An OpenAI model for reasoning

*   The browser session instance from Step 3

*   A specific task to perform


**Models:**
This example uses **GPT-4o**, but you can use any browser-use compatible models like Anthropic, DeepSeek, or Gemini. See the full list of supported models here.

#### Step 6: Run your Agent

```python Python -wcn -f main.py
import time

# Define the main function with the agent execution
async def main():
    try:
        start_time = time.time()

        print(f"üéØ Executing task: {task}")
        print("=" * 60)

        # Run the agent
        result = await agent.run()

        duration = f"{(time.time() - start_time):.1f}"

        print("\n" + "=" * 60)
        print("üéâ TASK EXECUTION COMPLETED")
        print("=" * 60)
        print(f"‚è±Ô∏è  Duration: {duration} seconds")
        print(f"üéØ Task: {task}")
        if result:
            print(f"üìã Result:\n{result}")
        print("=" * 60)

    except Exception as e:
        print(f"‚ùå Task execution failed: {e}")
    finally:
        # Clean up resources
        if session:
            print("Releasing Steel session...")
            client.sessions.release(session.id)
            print(f"Session completed. View replay at {session.session_viewer_url}")
        print("Done!")

# Run the async main function
if __name__ == '__main__':
    asyncio.run(main())
```


The agent will spin up a steel browser session and interact with it to complete the task. After completion, it's important to properly close the browser and release the Steel session.

#### Complete example

Here's the complete script that puts all steps together:

```python Python -wcn -f main.py
"""
AI-powered browser automation using browser-use library with Steel browsers.
https://github.com/steel-dev/steel-cookbook/tree/main/examples/steel-browser-use-starter
"""

import os
import time
import asyncio
from dotenv import load_dotenv
from steel import Steel
from browser_use import Agent, BrowserSession
from browser_use.llm import ChatOpenAI

load_dotenv()

# Replace with your own API keys
STEEL_API_KEY = os.getenv("STEEL_API_KEY") or "your-steel-api-key-here"
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY") or "your-openai-api-key-here"

# Replace with your own task
TASK = os.getenv("TASK") or "Go to Wikipedia and search for machine learning"

tools = Tools()

client = Steel(steel_api_key=STEEL_API_KEY)

SESSION_CACHE: Dict[str, Any] = {}

def _has_active_captcha(states: List[Dict[str, Any]]) -> bool:
    for state in states:
        if bool(state.get("isSolvingCaptcha")):
            return True
    return False


def _summarize_states(states: List[Dict[str, Any]]) -> Dict[str, Any]:
    summary: Dict[str, Any] = {
        "pages": [],
        "active_pages": 0,
        "total_tasks": 0,
        "solving_tasks": 0,
        "solved_tasks": 0,
        "failed_tasks": 0,
    }

    for state in states:
        tasks = state.get("tasks", []) or []
        solving = sum(1 for t in tasks if t.get("status") == "solving")
        solved = sum(1 for t in tasks if t.get("status") == "solved")
        failed = sum(
            1
            for t in tasks
            if t.get("status") in ("failed_to_detect", "failed_to_solve")
        )

        summary["pages"].append(
            {
                "pageId": state.get("pageId"),
                "url": state.get("url"),
                "isSolvingCaptcha": bool(state.get("isSolvingCaptcha")),
                "taskCounts": {
                    "total": len(tasks),
                    "solving": solving,
                    "solved": solved,
                    "failed": failed,
                },
            }
        )
        summary["active_pages"] += 1 if bool(state.get("isSolvingCaptcha")) else 0
        summary["total_tasks"] += len(tasks)
        summary["solving_tasks"] += solving
        summary["solved_tasks"] += solved
        summary["failed_tasks"] += failed

    return summary


@tools.action(
    description=(
        "You need to invoke this tool when you encounter a CAPTCHA. It will get a human to solve the CAPTCHA and wait until the CAPTCHA is solved."
    )
)
def wait_for_captcha_solution() -> Dict[str, Any]:
    session_id = SESSION_CACHE.get("session_id")
    timeout_ms = 60000
    poll_interval_ms = 1000

    start = time.monotonic()
    end_deadline = start + (timeout_ms / 1000.0)
    last_states: List[Dict[str, Any]] = []

    while True:
        now = time.monotonic()
        if now > end_deadline:
            duration_ms = int((now - start) * 1000)
            return {
                "success": False,
                "message": "Timeout waiting for CAPTCHAs to be solved",
                "duration_ms": duration_ms,
                "last_status": _summarize_states(last_states) if last_states else {},
            }
        try:
            # Convert CapchaStatusResponseItems to dict
            last_states = [
                state.to_dict() for state in client.sessions.captchas.status(session_id)
            ]

        except Exception:
            duration_ms = int((time.monotonic() - start) * 1000)
            print(
                {
                    "success": False,
                    "message": "Failed to get CAPTCHA status; please try again",
                    "duration_ms": duration_ms,
                    "last_status": {},
                }
            )
            return "Failed to get CAPTCHA status; please try again"

        if not last_states:
            duration_ms = int((time.monotonic() - start) * 1000)
            print(
                {
                    "success": True,
                    "message": "No active CAPTCHAs",
                    "duration_ms": duration_ms,
                    "last_status": {},
                }
            )
            return "No active CAPTCHAs"

        if not _has_active_captcha(last_states):
            duration_ms = int((time.monotonic() - start) * 1000)
            print(
                {
                    "success": True,
                    "message": "All CAPTCHAs solved",
                    "duration_ms": duration_ms,
                    "last_status": _summarize_states(last_states),
                }
            )
            return "All CAPTCHAs solved"

        time.sleep(poll_interval_ms / 1000.0)



async def main():
    print("üöÄ Steel + Browser Use Assistant")
    print("=" * 60)

    if STEEL_API_KEY == "your-steel-api-key-here":
        print("‚ö†Ô∏è  WARNING: Please replace 'your-steel-api-key-here' with your actual Steel API key")
        print("   Get your API key at: https://app.steel.dev/settings/api-keys")
        return

    if OPENAI_API_KEY == "your-openai-api-key-here":
        print("‚ö†Ô∏è  WARNING: Please replace 'your-openai-api-key-here' with your actual OpenAI API key")
        print("   Get your API key at: https://platform.openai.com/api-keys")
        return

    print("\nStarting Steel browser session...")

    try:
        session = client.sessions.create()
        print("‚úÖ Steel browser session started!")
        print(f"View live session at: {session.session_viewer_url}")

        print(
            f"\033[1;93mSteel Session created!\033[0m\n"
            f"View session at \033[1;37m{session.session_viewer_url}\033[0m\n"
        )

        cdp_url = f"wss://connect.steel.dev?apiKey={STEEL_API_KEY}&sessionId={session.id}"

        model = ChatOpenAI(model="gpt-4o", temperature=0.3, api_key=OPENAI_API_KEY)
        agent = Agent(task=TASK, llm=model, browser_session=BrowserSession(cdp_url=cdp_url), tools=tools)

        start_time = time.time()

        print(f"üéØ Executing task: {TASK}")
        print("=" * 60)

        try:
            result = await agent.run()

            duration = f"{(time.time() - start_time):.1f}"

            print("\n" + "=" * 60)
            print("üéâ TASK EXECUTION COMPLETED")
            print("=" * 60)
            print(f"‚è±Ô∏è  Duration: {duration} seconds")
            print(f"üéØ Task: {TASK}")
            if result:
                print(f"üìã Result:\n{result}")
            print("=" * 60)

        except Exception as e:
            print(f"‚ùå Task execution failed: {e}")
        finally:
            if session:
                print("Releasing Steel session...")
                client.sessions.release(session.id)
                print(f"Session completed. View replay at {session.session_viewer_url}")
            print("Done!")

    except Exception as e:
        print(f"‚ùå Failed to start Steel browser: {e}")
        print("Please check your STEEL_API_KEY and internet connection.")


if __name__ == "__main__":
    asyncio.run(main())
```


Save this as main.py and run it with:

#### Customizing your agent's task

Try modifying the task to make your agent perform different actions:

```python Python -wcn -f main.py
TASK="""
1. Go to https://recaptcha-demo.appspot.com/recaptcha-v2-checkbox.php
2. If you see a CAPTCHA box, use the wait_for_captcha_solution tool to solve it
3. Once the CAPTCHA is solved, submit the form
4. Return the result
"""
```


Congratulations! You've successfully connected a Steel browser session with browser-use to solve a CAPTCHA.
